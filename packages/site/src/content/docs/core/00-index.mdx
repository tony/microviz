---
title: "@microviz/core"
slug: core
---

Headless compute utilities and shared types for micro-visualizations.

This package is SSR-safe and does not rely on DOM APIs.

## Install

```bash
pnpm add @microviz/core
```

## Compute a `RenderModel`

`computeModel()` is the canonical entry point. It is deterministic (same inputs → same outputs) and returns a serializable `RenderModel`.

```ts
import { computeModel } from "@microviz/core";

const model = computeModel({
  data: [6, 10, 7, 12, 9, 14],
  size: { width: 200, height: 32 },
  spec: { type: "sparkline" },
});
```

## Diagnostics (catch “blank/incorrect render” early)

Every model includes computed stats and warnings:

```ts
const warnings = model.stats?.warnings ?? [];
if (warnings.length > 0) {
  // BLANK_RENDER, NAN_COORDINATE, MARK_OUT_OF_BOUNDS, MISSING_DEF, EMPTY_DATA, ...
  console.log(warnings);
}
```

## Hit testing

`hitTest()` lets you map pointer coordinates to a mark ID/type. Coordinates are
in **model space** (same as the SVG `viewBox`: `0..width`, `0..height`):

```ts
import { hitTest } from "@microviz/core";

const hit = hitTest(model, { x: 42, y: 12 }, { strokeSlopPx: 2 });
if (hit) console.log(hit.markId, hit.markType);
```

## Def fill rules (nivo-inspired)

When you have defs (patterns/gradients) and want to apply them via match rules:

```ts
import { applyFillRules, computeModel } from "@microviz/core";

const model = computeModel({ data, size, spec });
const marks = applyFillRules(model.marks, [
  { id: "pat-1", match: { className: /mv-stripe-density/ } },
]);

const withFills = { ...model, marks };
```

## Chart types

To list the available chart types (and their metadata):

```ts
import { getAllChartMeta } from "@microviz/core";

const chartTypes = getAllChartMeta().map((meta) => meta.type);
```
